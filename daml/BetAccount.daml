module BetAccount where

import Account
import DA.Foldable (forA_)
import DA.Action (foldlA)

data Winner = Winner with
    user: Party
    amount: Decimal
      deriving (Eq, Show)

template BetAccounts
  with
    users: [Party]
    amount: Decimal
    house: Party

  where
    signatory house
    observer users

    choice AddUserAndBet: ContractId BetAccounts
      with
        newUser: Party
        betAmount: Decimal

      controller house
      do
        assertMsg "Bet amount must be positive" (betAmount > 0.0)

        let newUsers = users ++ [newUser]

        create this with
          users = newUsers
          amount = amount + betAmount

    nonconsuming choice PayOut: [ContractId Account.Transfer] --for generating account contracts for winning bets
      with
        assetCids: [ContractId Account]
        winners: [Winner]
        totalAmount: Decimal
        assetType: AssetType

      controller house
      do
        assertMsg "Account is non fungible" assetType.fungable
        --archive all input contracts and a list of output contacts in the given denomination
        forA_ assetCids archive 

        let
          --defines a function that creates an output asset of the given denomination and transfer to winner
          createOutputAssets assetsList winner = do
            assertMsg "The amount of the output asset must be positive" $ winner.amount > 0.0
            accountCid <- create Account with
              assetType
              owner = house
              amount = winner.amount
              observers = []
            newAccount <- fetch accountCid
            accountTransfer <- create Account.Transfer with
              asset = newAccount
              recipient = winner.user
            return $ accountTransfer :: assetsList --adding to the list 

        foldlA createOutputAssets []  winners --need to UTXO back to house
        -- if totalAmount > sum winners.outputAmounts then do
        --     a <- create Account with
        --     assetType
        --     owner=house
        --     amount=totalAmount - sum outputAmounts 
        --     observers=[]
        --     return $a ::outputAssetCids
        -- else  
        --return outputAssetCids    

    nonconsuming choice SubmitPayment: ContractId Account.Transfer
      with
        userAccount: Account
        user: Party
        betAmount: Decimal  

      controller user
      do
        assertMsg "Insufficent balance" $(userAccount.amount > betAmount)
         --creating new BetAccount
        create Account.Transfer with
          asset = userAccount
          recipient = house

    choice AddNewBet: ContractId BetAccounts --house accept the bet and
      with
        user: Party
        transferCid: ContractId Transfer

      controller house
      do
        betTransfer <- fetch transferCid
        
        exercise transferCid Transfer_Accept 

        let newAmount = amount + betTransfer.asset.amount --calculating the total bet amount
        let newUsers = users ++ [user]

        create BetAccounts with
          users = newUsers
          amount = newAmount
          house
    

