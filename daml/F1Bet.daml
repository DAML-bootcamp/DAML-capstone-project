module F1Bet where

import BetAccount
import SchedulingData

data BetStatus = Open | Placed | Settled
  deriving (Eq, Show)

data RacerBet = RacerBet with --represents a user bet
  user: Party
  betAmount: Decimal
  betRacer: Racer
    deriving (Show, Eq)

template F1Bet
  with
    house: Party
    racerBets: [RacerBet] --represents each user and the betscore for that match
    odds: Decimal
    raceStatus: Text --represents final score of the match
    betStatus: BetStatus
    maxPayout: Int

  where
    signatory house

    choice UpdateBetStatus: ContractId F1Bet
      with
        newBetStatus: BetStatus
      controller house
      do
        assertMsg  "Cannot update to the same status" $ newBetStatus == betStatus
        create this with betStatus = newBetStatus

    choice UpdateBetOdds: ContractId F1Bet --updates with new odds of winning
      with
        newOdds: Decimal
      controller house
      do
       -- assert (newOdds /= odds) "Cannot update to the same odds"
        create this with odds = newOdds

    choice CalculateBetWinnings: [Winner] -- calculates winners and amount to be paid out
      with
        raceWinner: Racer --represents the current race result
      controller house
      do
        assertMsg "Cannot calculate winnings for an ongoing bet" $ betStatus == Settled
        let calculateWinningAmount racerBet = 
              if (racerBet.betRacer == raceWinner)
                then racerBet.betAmount + (racerBet.betAmount * odds)
                else 0.0
        
        let
          winners = [ Winner with user = racerBet.user, amount = calculateWinningAmount racerBet
                      | racerBet <- racerBets, calculateWinningAmount racerBet > 0.0 ]

        return winners


            
        

       


